简历：
使用 Spring Boot 开发 REST API，
实现基于 JWT 的登录鉴权，
通过 AOP 处理事务与日志


【能力要求】：
1、Java基础扎实，理解IO、多线程、集合等基础架构，熟悉JVM原理，熟悉常用的Java开源框架，对使用过的框架能了解到原理和机制，熟悉springboot，springcloud等常用开源框架；
2、了解互联网系统的架构，2年以上的高可用、分布式大型系统架构和开发经验，丰富的线上运维经验，熟悉缓存、消息等机制，熟悉开源中间件的使用，了解其原理和机制。
3、有高并发、高可用性系统设计与开发的经验，有性能调优的经验，掌握多线程及高性能的设计与编码及性能调优；有高并发应用开发经验。
4、对数据抽象、领域建模等有相关的工作经验，有大数据处理及算法经验者优先。（Hadoop/Spark/Flink/Kafka等大数据与流处理技术）
5、掌握Linux 操作系统和大型数据库（Oracle、MySql）、对sql优化有丰富的经验。
6、具备良好的设计通用框架及模块的能力。具备良好的系统分析能力、抽象能力，擅长分析复杂问题和解决问题。



根据上面的要求，总结如下：
1. Spring Boot启动流程
从SpringApplication.run()开始的关键步骤（加载配置、创建上下文、刷新上下文等）。

内嵌Web服务器（如Tomcat）的启动过程。

2. 请求参数处理
@RequestParam、@RequestBody、@Valid校验参数

全局异常处理（@ControllerAdvice和@ExceptionHandler）。
@ControllerAdvice：全局异常处理和全局数据绑定的注解。
@ExceptionHandler(异常类.class)，处理指定类型的异常。

3. 拦截器（Interceptor）与过滤器（Filter）对比

维度	过滤器（Filter）	拦截器（Interceptor）
所属规范	Servlet规范（javax.servlet）	Spring MVC框架（org.springframework.web.servlet）
作用范围	所有Web资源（Servlet、JSP、静态资源）	只针对Spring MVC管理的控制器（Controller）
依赖	不依赖Spring框架，可在任何Java Web应用中使用	依赖Spring MVC框架
执行时机	在请求进入Servlet之前，响应离开Servlet之后	在DispatcherServlet处理请求前后
获取Spring Bean	无法直接注入Spring Bean（需通过其他方式）	可直接使用Spring依赖注入

执行流程：
HTTP Request → Tomcat → Filter Chain → DispatcherServlet → Interceptor Chain → Controller
           ↓                                                      ↓
HTTP Response ← Tomcat ← Filter Chain ← DispatcherServlet ← Interceptor Chain ← Controller

DispatcherServlet负责：将接收到的HTTP请求，发给相应的控制器处理

1) Filter：IP黑白名单 → 字符编码设置 → CORS处理
2) Interceptor：登录验证 → 权限校验 → 接口日志
3) AOP：业务层日志 → 事务管理 → 性能监控


常见面试问题
1）过滤器和拦截器的执行顺序是怎样的？

过滤器在DispatcherServlet之前执行，拦截器在DispatcherServlet之后执行

多个过滤器按注册顺序执行，多个拦截器按配置顺序执行

2）过滤器中可以注入Spring Bean吗？

直接使用@Autowired无效，需要通过WebApplicationContextUtils获取

或使用Spring的DelegatingFilterProxy

3）什么情况下拦截器的postHandle方法不会执行？

preHandle返回false时

Controller抛出异常且未被@ControllerAdvice捕获时

4）如何全局捕获Controller异常？

使用@ControllerAdvice + @ExceptionHandler（在拦截器之后执行）

无法在过滤器中捕获Controller异常

5）如何处理静态资源？

过滤器可以处理所有静态资源

拦截器默认不处理静态资源，需通过配置排除


4. Spring Data JPA
4.1 关联关系注解
一对一（One-to-One）

@Entity
public class User {
    @Id
    private Long id;
    
    @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = "address_id", referencedColumnName = "id")
    private Address address;  // 用户拥有一个地址
}

@Entity
public class Address {
    @Id
    private Long id;
    
    @OneToOne(mappedBy = "address")
    private User user;  // 地址被一个用户拥有
}


一对多（One-to-Many）
@Entity
public class Department {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Employee> employees = new ArrayList<>();
    // mappedBy表示关系由Employee类的department属性维护
}

@Entity
public class Employee {
    @Id
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "dept_id")
    private Department department;  // 外键维护方
}


一对多（One-to-Many）
@Entity
public class Department {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Employee> employees = new ArrayList<>();
    // mappedBy表示关系由Employee类的department属性维护
}

@Entity
public class Employee {
    @Id
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "dept_id")
    private Department department;  // 外键维护方
}

4.2 方法命名规则查询
findBy/readBy/queryBy/getBy/countBy/deleteBy + 属性 + 条件

// 1. 简单条件查询
User findByUsername(String username);
List<User> findByEmail(String email);
User findByUsernameAndEmail(String username, String email);

// 2. 比较查询
List<User> findByAgeGreaterThan(int age);
List<User> findByAgeLessThanEqual(int age);  // 小于等于
List<User> findByAgeBetween(int min, int max);
List<User> findByAgeNotBetween(int start, int end);  // 不在区间内
List<User> findByAgeIn(Collection<Integer> ages);
List<User> findByAgeNotIn(Collection<Integer> ages);
List<User> findByCreateTimeAfter(Date date);       // 创建时间晚于指定时间
List<User> findByCreateTimeBefore(Date date);      // 创建时间早于指定时间

// 3. 模糊查询
List<User> findByUsernameContaining(String keyword);
List<User> findByUsernameLike(String pattern);  // %keyword%
List<User> findByUsernameStartingWith(String prefix);
List<User> findByUsernameEndingWith(String suffix);

// 4. 排序查询
List<User> findByAgeOrderByCreateTimeDesc(int age);
List<User> findByStatusOrderByUsernameAscCreateTimeDesc(UserStatus status);

// 5. 统计查询
long countByStatus(UserStatus status);
boolean existsByEmail(String email);
int deleteByStatus(UserStatus status);

// 6. 关联查询
List<User> findByDepartmentName(String deptName);
List<User> findByDepartment_Id(Long deptId);  // 使用下划线访问关联对象属性

// 空值检查
List<User> findByEmailIsNull();      // email为NULL
List<User> findByEmailIsNotNull();   // email不为NULL

// 结合其他条件
List<User> findByEmailIsNotNullAndStatus(UserStatus status);

4.3 @Query注解查询
JPQL查询（面向实体）

    @Query("SELECT u FROM User u WHERE u.username = :name OR u.email = :email")
    User findByNameOrEmail(@Param("name") String username, @Param("email") String email);


原生SQL查询：
    @Query(value = "SELECT * FROM users u WHERE u.age > :age", nativeQuery = true)
    List<User> findUsersOlderThan(@Param("age") int age);


5. 事务管理

5.1 @Transactional的工作原理
底层实现 - AOP代理，执行流程：

1）代理创建：Spring启动时，为标注@Transactional的类生成动态代理（JDK动态代理或CGLIB）
2）拦截执行：调用方法时，代理先执行事务管理逻辑

3）事务管理：
    开启事务（获取数据库连接，设置autocommit=false）
    执行业务方法
    提交事务或回滚事务

4）异常处理：遇到RuntimeException/Error时回滚，正常执行则提交


理解代理：
老板（真实对象）：专注于核心业务（处理重要事务）
秘书（代理对象）：帮老板处理杂务（安排会议、接电话、记录日程）


静态代理（手动编写代理类）：要为每个类都写一个代理类，工作量巨大。如果要为100个Service添加事务，要写100个代理类。
动态代理（运行时自动生成代理类）：在程序运行时，动态地为目标类生成代理类。


@Transactional的实现机制是：Spring基于AOP思想，使用TransactionInterceptor这个具体的拦截器来实现事务管理。

说它是Aspect：因为它遵循AOP的横切关注点思想，将事务逻辑从业务代码中分离，通过代理模式实现。

说它是Interceptor：因为具体实现类TransactionInterceptor实现了AOP联盟标准的MethodInterceptor接口，使用标准的拦截器模式在执行目标方法前后添加事务逻辑。

更准确的说法：@Transactional是Spring AOP框架的一个具体应用，底层通过TransactionInterceptor拦截器实现，提供声明式事务管理功能。它利用了Spring的代理机制（JDK动态代理或CGLIB），在运行时为标注@Transactional的Bean创建代理对象，通过拦截器添加事务管理逻辑。



Spring如何选择JDK代理还是CGLIB代理：

// Spring Boot的配置
@Configuration
@EnableAspectJAutoProxy(proxyTargetClass = true)  // true=CGLIB, false=JDK
public class AppConfig {
}

// 或者application.properties配置
// spring.aop.proxy-target-class=true  # 强制使用CGLIB

**选择策略：**
默认情况：
目标类实现了接口 → 使用JDK动态代理
目标类没有实现接口 → 使用CGLIB动态代理

强制使用CGLIB：
设置proxyTargetClass = true
统一使用CGLIB，避免类型转换问题

5.2 事务的传播行为（Propagation）
传播行为定义了多个事务方法相互调用时，事务如何传播。

7种传播行为详解
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@Service
public class OrderService {
    
    @Autowired
    private UserService userService;
    
    // REQUIRED（默认）：如果当前存在事务，则加入该事务；如果不存在，则创建新事务
    @Transactional(propagation = Propagation.REQUIRED)
    public void placeOrder(Order order) {
        // 方法A的事务
        saveOrder(order);
        
        try {
            // 调用另一个事务方法
            userService.updateUserPoints(order.getUserId(), order.getPoints());
        } catch (Exception e) {
            // 异常处理
        }
        // REQUIRED：updateUserPoints加入placeOrder的事务
        // 如果updateUserPoints抛出异常，整个事务回滚（包括saveOrder）
    }
}

@Service
public class UserService {
    
    // REQUIRES_NEW：无论当前是否存在事务，都创建新事务
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateUserPoints(Long userId, Integer points) {
        // 创建新事务，与调用方的事务独立
        // 自己的提交/回滚不影响调用方事务
    }
    
    // NESTED：如果当前存在事务，则在嵌套事务内执行
    @Transactional(propagation = Propagation.NESTED)
    public void logUserAction(UserAction action) {
        // 嵌套事务：外部事务回滚会导致嵌套事务回滚
        // 但嵌套事务可以独立回滚而不影响外部事务
    }
    
    // SUPPORTS：如果当前存在事务，则加入事务；如果不存在，则以非事务方式执行
    @Transactional(propagation = Propagation.SUPPORTS)
    public User getUser(Long id) {
        // 查询方法，不需要强制事务
    }
    
    // NOT_SUPPORTED：以非事务方式执行，如果当前存在事务则挂起
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void sendNotification(Notification notification) {
        // 发消息、日志等非数据库操作
    }
    
    // MANDATORY：强制必须在事务中调用，否则抛出异常
    @Transactional(propagation = Propagation.MANDATORY)
    public void auditLog(AuditLog log) {
        // 必须在外层事务中调用
    }
    
    // NEVER：必须在非事务环境下执行，否则抛出异常
    @Transactional(propagation = Propagation.NEVER)
    public String generateReport() {
        // 生成报表，不希望被事务影响性能
    }
}

5.3 隔离级别（Isolation）

并发问题与隔离级别对应关系
隔离级别	脏读	不可重复读	幻读	性能
READ_UNCOMMITTED	可能	可能	可能	最高
READ_COMMITTED	避免	可能	可能	高
REPEATABLE_READ	避免	避免	可能	中
SERIALIZABLE	避免	避免	避免	最低

5.4 声明式事务与编程式事务的区别。

特性	声明式事务	编程式事务
实现方式	通过注解或XML配置	通过编程代码手动控制
侵入性	非侵入式（不影响业务逻辑）	侵入式（与业务代码耦合）
核心组件	@Transactional 注解、AOP代理	TransactionTemplate、PlatformTransactionManager
使用场景	大多数业务场景	需要精细控制的复杂场景

代码简洁性	✅ 简洁，一行注解	❌ 代码冗长，需要模板代码
业务逻辑分离	✅ 事务管理与业务逻辑完全分离	❌ 事务代码与业务逻辑混合
灵活性	❌ 相对固定，配置有限	✅ 极高灵活性，可动态控制
可读性	✅ 清晰直观，关注业务	❌ 事务代码干扰业务逻辑
性能	稍有开销（AOP代理）	直接控制，开销较小
错误处理	自动回滚（声明异常）	可精细控制回滚时机
适用场景	标准CRUD、常规业务	复杂业务流、需要条件提交/回滚

声明式事务（工作原理：AOP代理）：
@Service
public class UserService {
    
    // 最简单的声明式事务
    @Transactional
    public void updateUser(User user) {
        // 业务逻辑
        userRepository.save(user);
        // 如果抛出异常，事务自动回滚
    }
    
    // 带配置的声明式事务
    @Transactional(
        propagation = Propagation.REQUIRED,
        isolation = Isolation.DEFAULT,
        rollbackFor = Exception.class,
        timeout = 30
    )
    public void batchUpdate(List<User> users) {
        // 批量操作
    }
}

编程式事务，例如TransactionTemplate方式：
@Service
public class OrderService {
    
    @Autowired
    private TransactionTemplate transactionTemplate;
    
    public void complexOrderProcess(Order order) {
        // 使用TransactionTemplate执行事务
        transactionTemplate.execute(status -> {
            try {
                // 步骤1：创建订单
                orderRepository.save(order);
                
                // 步骤2：扣减库存
                inventoryService.deduct(order);
                
                // 步骤3：记录日志
                logService.record(order);
                
                // 手动设置只读（如果需要）
                // status.setRollbackOnly(); // 手动回滚
                
                return true;
            } catch (Exception e) {
                // 发生异常，事务会自动回滚
                // 也可以手动回滚：status.setRollbackOnly();
                throw e;
            }
        });
    }
}


5.5 Exception VS Error

特性	Exception	Error
继承关系	Throwable ← Exception	Throwable ← Error
可恢复性	✅ 可恢复（通过捕获处理）	❌ 不可恢复（严重系统问题）
产生原因	程序逻辑问题、外部条件变化	JVM系统级问题、资源耗尽
处理建议	应该捕获并处理	不应该捕获（捕获也无意义）
子类示例	IOException, SQLException, NullPointerException	OutOfMemoryError, StackOverflowError, VirtualMachineError
是否受检	分为Checked和Unchecked	全部是Unchecked（运行时）

// Java异常体系完整视图
        Throwable (可抛出)
          /      \
     Error       Exception
                   /     \
              RuntimeException  其他Checked Exception
                  |
         各种Unchecked Exception

// 代码表示
Object
  └─ Throwable
      ├─ Error (系统错误，不可恢复)
      │    ├─ VirtualMachineError
      │    │    ├─ OutOfMemoryError
      │    │    ├─ StackOverflowError
      │    │    └─ InternalError
      │    ├─ LinkageError
      │    │    ├─ NoClassDefFoundError
      │    │    └─ ClassFormatError
      │    └─ AssertionError
      │
      └─ Exception (异常，可恢复)
           ├─ RuntimeException (Unchecked)
           │    ├─ NullPointerException
           │    ├─ IllegalArgumentException
           │    ├─ IndexOutOfBoundsException
           │    ├─ ClassCastException
           │    └─ ArithmeticException
           │
           └─ Checked Exception (必须处理)
                ├─ IOException
                │    ├─ FileNotFoundException
                │    └─ EOFException
                ├─ SQLException
                ├─ ParseException
                ├─ InterruptedException
                └─ ClassNotFoundException 


6. 数据库连接池

6.1 默认连接池（HikariCP）的配置优化。

连接池的核心参数
参数	说明	默认值/建议
maximumPoolSize	最大连接数	CPU核数 * 2 （如果是Web，可以多点）
minimumIdle	最小空闲连接	同maximumPoolSize
connectionTimeout	连接获取超时	30秒
idleTimeout	空闲连接超时	10分钟
maxLifetime	连接最大生命周期	30分钟
validationTimeout	验证查询超时	5秒


# 配置参考表格
应用类型         | 并发特点           | 推荐范围     | 计算基准
----------------|-------------------|-------------|----------
电商订单服务     | 高并发，短连接     | 50-200      | CPU核心 × 8
内容管理系统     | 中等并发，读多写少 | 20-50       | CPU核心 × 4
数据分析平台     | 低并发，长查询     | 10-30       | CPU核心 × 2
API网关         | 极高并发，快速响应 | 100-300     | CPU核心 × 10

本地开发：用10-20足够了，资源留给其他应用
测试环境：20-50，模拟生产并发
生产环境：
  起点：从CPU逻辑核心数×4开始
  优化：通过监控和压测调整
  上限：不超过数据库限制的80%
监控指标：
  - Active Connections: 活跃连接数（应小于maximumPoolSize的80%）
  - Idle Connections: 空闲连接数
  - Connection Wait Time: 获取连接等待时间（应<100ms）
  - Connection Timeout Count: 连接超时次数（应为0）

监控数据库连接使用率
SHOW PROCESSLIST;  -- 查看当前连接
SHOW STATUS LIKE 'Threads_connected';  -- 总连接数
SHOW VARIABLES LIKE 'max_connections';  -- 最大连接数

你的maximumPoolSize怎么确定的？
1） 理论基准（展示知识）：
   "我会参考多个因素，而不是简单套用公式。首先会基于CPU核心数作为起点，
   现代SSD环境下，磁盘数不再重要，更多考虑并发特性。"

2） 实际方法（展示经验）：
   "在实际项目中，我会：
   a) 先用保守值（如20）启动
   b) 进行压测，观察性能拐点
   c) 监控生产环境连接使用率
   d) 根据业务增长动态调整"

3） 具体数值（展示专业性）：
   "对于我们的电商订单服务：
   - CPU：16核
   - 理论最大：16×8=128
   - 实际配置：80（留出buffer）
   - 监控显示：峰值使用60，平均30"

4） 安全考虑（展示周全性）：
   "同时我会确保：
   - 不超过数据库max_connections的80%
   - 设置合理的connection-timeout防止线程阻塞
   - 开启leak-detection检测连接泄露"


HikariCP是一个高性能的JDBC连接池:
性能对比：HikariCP > Druid > Tomcat JDBC > DBCP2
内存消耗：HikariCP < 其他连接池

1）数据库连接池解决了什么问题？
答：解决了频繁创建/关闭数据库连接的性能问题：
A. 减少连接创建开销（TCP三次握手、认证等）
B. 控制并发连接数，保护数据库
C. 统一管理连接状态和生命周期
D. 提供连接复用，提升响应速度

6.2 多数据源配置。


